# PyDimanify
Код - говнянный, знаю. Однако всё создано по рофлу, так что пофиг. Делал я от скуки, точнее не я, а чатгпт, название в честь диманисета.

Начну сразу.
Вывод в консоль:
```py
вывод("Привет, димани!")
```

# Тексты
Класс объявляется так:
```py
текст("любой текст и т.д.")
```

Список действий с классом:
- ```.вывести()``` выведет содержимое класса
- ```.капс()``` КАПСИТ, ЛОГИЧНО
- ```.низ()``` превращает текст в низкую раскладку
- ```.спросить()``` получает текст введённый пользователем в консоль.
- ```.вернуть()``` ретурнит содержимое класса

# Переменные
Класс объявляется так:
```py
переменная("str/int/list/bool", содержимое)
```

Список действий с классом:
- ```.присвоить(число)``` Прибавляет число и меняет значение
- ```.прибавить(число)``` Не меняет значение, просто прибавляет
- ```.уравнить(новое значение)``` Меняет значение переменной на то, что вы написали
- ```.вывести()``` аналогично с текстами - выводит содержимое переменной
- ```.значение()``` ретурнит содержимое переменной

# Функции
Создание функции без аргументов:

```py
функция = функ("название функции")
функция.добавить([
  'вывод("Функция вызвана!")' 
])
функция.выполнить()
```

С аргументами:

```py
функция = функ("название функции", "аргумент1", ...)
функция.добавить([
  'вывод("Значение аргумента: ;аргумент1")',
  'вывод("Экранизация: \;аргумент1")'
])
функция.выполнить("значение аргумента1", ...)
```

Получить имя функции - ```.название()```

# Условия
Благодаря условиям вы впринципе можете сделать проверку чего нибудь, например, если 5 < 10

```py
#в лямбде пишем само условие
условие1 = условие(lambda: 5 < 10)
#код если это верно
условие1.если([
  lambda: вывод("всё ок бро, 5 меньше 10")
])
#иначе
условие1.иначе([
  lambda: вывод("чооо 5 не меньше 10???"),
])
#и выполним условие
условие1.выполнить()
```

# Циклы
Пример цикла **когда**:

```py
#переменная, в которой мы будем считать количество повторений
перем = переменная("int", 1)

#через lambda напишем условия, при которых будет работать цикл
циклик = когда(lambda: перем.значение() <= 10)
циклик.добавить([
#код тоже в ламбда
  lambda: вывод(перем),
  lambda: перем.присвоить(1)
])
циклик.выполнить()
```

Пример цикла **для**:

```py
#второй аргумент - название аргумента для цикла
фор = для(диапозон(11), "pon")
фор.добавить([
#.вернуть_название_аргумента() всё понятно
#.вернуть_аргумент() возращает значение вашего аргумента, указанного в первой строке цикла
  lambda: вывод(f"{фор.вернуть_название_аргумента()}: {фор.вернуть_аргумент()}")
])
фор.выполнить()
```

# Файлы
Работа с файлами теперь возможна на... кириллице!

Открыть файл: 
```py
файл("путь", "тип") # типы такие же как в open
```

Дальнейшие действия:
- ```.читать(сколько символов/пусто)``` читать файл
- ```.читать_строки()``` читать построчно
- ```.записать("содержимое")``` записать в конец файла чо нибудь
- ```.записать_строку(список)``` записать список в файл

# Рандом
Функции:
```py
рандом.выбор(массив) #рандом элемент из массива
рандом.число(от, до) #рандом число от до(напр от 0 до 100)
```

# Запросы

Создаем объект запрос с адресом URL

```py
мой_запрос = запрос("https://jsonplaceholder.typicode.com/posts")
```

GET запрос

```py
ответ = мой_запрос.получить()
вывод(ответ.json())
```

POST запрос

```py
данные = {'title': 'foo', 'body': 'bar', 'userId': 1}
ответ = мой_запрос.пост(жсон=данные)
вывод(ответ.json())
```

PUT запрос

```py
данные = {'title': 'foo', 'body': 'bar', 'userId': 1}
ответ = мой_запрос.положить(данные=данные)
вывод(ответ.json())
```

DELETE запрос

```py
ответ = мой_запрос.удалить()
вывод(ответ.status_code)
```

# Цепи маркова

Це́пь Ма́ркова — последовательность случайных событий с конечным или счётным числом исходов, где вероятность наступления каждого события зависит от состояния, достигнутого в предыдущем событии. Характеризуется тем свойством, что, говоря нестрого, при фиксированном настоящем будущее независимо от прошлого.(Ааа викепедия)

Пример кода на диманифи, в котором мы сгенерируем чо то с помощью цепи маркова
```py
from dimanify import *

файлик = файл("dataset.txt", "r").читать()

# создадим модель, первый аргумент - текст, на основе которого мы будем генерировать текст
# как первый аргумент я сделал содержимое файла dataset.txt
# размер состояния - размер состояния в цепи маркова пон
цепь = марков(файлик, размер_состояния=2)

#генерируем
#аргумент "слов" - количество слов, которые мы сгенерируем
результат = цепь.создать(слов = 5)

#выведем результат
вывод(результат)
```

# Disetify
Disetify - это мини библиотека для создания бота на PyDimanify пон
Чтобы подключить, зайдите в файл dimanify.py и добавьте строку 
```py
from core.disetify import *
```

Для начала создадим переменную бота с классом Бот со всеми интентами лол
```py
интенты = disnake.Intents.all()

бот = Бот(
  префикс = "ваш префикс",
  токен = "ваш токен",
  интенты = интенты
)
```

Создадим парочку команд
```py
бот.команда(
  название="кинь кота",
  ответ="https://tenor.com/view/byuntear-sad-sad-cat-cat-meme-gif-25617057",
  пинг=True #ответит ли бот или тупо отправит сообщение
)

бот.команда(
  название="кинь собаку",
  ответ="https://tenor.com/view/dog-meme-gif-25326537",
  пинг=False
)
```

И запустим
```py
бот.запустить()
```

Вуаля!

<img width="948" alt="Без названия 6" src="https://user-images.githubusercontent.com/76626915/235769484-d2e2ef40-4c0a-4117-b342-a84bde447fd7.png">

# И наконец...
Димани, выходи за меня замуж!
Всё это создано для тебя! Я так старался!
